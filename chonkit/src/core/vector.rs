use crate::error::ChonkitError;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Collection properties.

pub const COLLECTION_ID_PROPERTY: &str = "collection_id";
pub const COLLECTION_NAME_PROPERTY: &str = "name";
pub const COLLECTION_SIZE_PROPERTY: &str = "size";
pub const COLLECTION_EMBEDDING_PROVIDER_PROPERTY: &str = "embedding_provider";
pub const COLLECTION_EMBEDDING_MODEL_PROPERTY: &str = "embedding_model";

// Vector payload properties.

pub const CONTENT_PROPERTY: &str = "content";
pub const DOCUMENT_ID_PROPERTY: &str = "document_id";

/// Used by vector databases.
#[derive(Debug, Serialize, Deserialize, Default, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct VectorCollection {
    /// Unique collection identifier generated by the (non-vector) database.
    pub id: Uuid,
    /// Unique collection name.
    pub name: String,
    /// Collection vector size
    pub size: usize,
    pub embedding_provider: String,
    pub embedding_model: String,
}

impl VectorCollection {
    pub fn new(
        id: Uuid,
        name: String,
        size: usize,
        embedding_provider: String,
        embedding_model: String,
    ) -> Self {
        Self {
            id,
            name,
            size,
            embedding_provider,
            embedding_model,
        }
    }

    pub fn with_id(mut self, id: Uuid) -> Self {
        self.id = id;
        self
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_size(mut self, size: usize) -> Self {
        self.size = size;
        self
    }

    pub fn with_embedding_provider(mut self, provider: String) -> Self {
        self.embedding_provider = provider;
        self
    }

    pub fn with_embedding_model(mut self, model: String) -> Self {
        self.embedding_model = model;
        self
    }
}

#[derive(Debug, Deserialize)]
pub struct VectorCollectionInfo {
    pub name: String,
    pub size: usize,
    pub embedding_provider: String,
    pub embedding_model: String,
}

#[derive(Debug, Serialize)]
pub struct CreateVectorCollection<'a> {
    pub collection_id: Uuid,
    pub name: &'a str,
    pub size: usize,
    pub embedding_provider: &'a str,
    pub embedding_model: &'a str,
}

impl<'a> CreateVectorCollection<'a> {
    pub fn new(
        id: Uuid,
        name: &'a str,
        size: usize,
        embedding_provider: &'a str,
        embedding_model: &'a str,
    ) -> Self {
        Self {
            collection_id: id,
            name,
            size,
            embedding_provider,
            embedding_model,
        }
    }
}

/// Vector database operations.
#[async_trait::async_trait]
pub trait VectorDb {
    fn id(&self) -> &'static str;

    /// List available vector collections.
    async fn list_vector_collections(&self) -> Result<Vec<VectorCollection>, ChonkitError>;

    /// Create a vector collection.
    ///
    /// * `name`: The name of the collection.
    /// * `size`: Vector size of the collection.
    async fn create_vector_collection(
        &self,
        data: CreateVectorCollection<'_>,
    ) -> Result<(), ChonkitError>;

    /// Get collection info.
    ///
    /// * `name`: Collection name.
    async fn get_collection(&self, name: &str) -> Result<VectorCollection, ChonkitError>;

    /// Delete a vector collection.
    ///
    /// * `name`: The name of the collection.
    async fn delete_vector_collection(&self, name: &str) -> Result<(), ChonkitError>;

    /// Used to create the initial collection.
    ///
    /// This is part of the interface in order to handle errors more efficiently,
    /// such as the collection already existing.
    ///
    /// As this method is called only on app start, it's fine to panic if something
    /// goes wrong.
    ///
    /// * `data`: Collection parameters.
    async fn create_default_collection(
        &self,
        data: CreateVectorCollection<'_>,
    ) -> Result<(), ChonkitError>;

    /// Perform semantic search.
    ///
    /// * `search`: The query to use as the search vector.
    /// * `collection`: The collection to search in.
    /// * `limit`: Amount of results to return.
    async fn query(
        &self,
        search: Vec<f64>,
        collection: &str,
        limit: u32,
    ) -> Result<Vec<String>, ChonkitError>;

    /// Store the contents and their vectors to the vector storage.
    /// The `contents` and `vectors` inputs are expected to
    /// be 1:1, i.e. the same index into both lists should
    /// yield the contents and their respectful embeddings.
    ///
    /// * `content`: The contents to append to the vectors.
    /// * `vectors`: The vectors to store.
    /// * `collection`: The vector collection to store in.
    async fn insert_embeddings(
        &self,
        document_id: Uuid,
        collection: &str,
        content: &[&str],
        vectors: Vec<Vec<f64>>,
    ) -> Result<(), ChonkitError>;

    /// Delete the vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to delete from.
    /// * `document_id`: The id of the document whose vectors to delete.
    async fn delete_embeddings(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<(), ChonkitError>;

    /// Returns the amount of vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to count in.
    /// * `document_id`: The id of the document whose vectors to count.
    async fn count_vectors(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<usize, ChonkitError>;
}
